NAME: Michael Wu
EMAIL: cheeserules43@gmail.com
ID: 404751542

Question 2.3.1

Where do you believe most of the cycles are spent in the 1 and 2-thread list
tests?

Why do you believe these to be the most expensive parts of the code?

Where do you believe most of the time/cycles are being spent in the high-thread
spin-lock tests?

Where do you believe most of the time/cycles are being spent in the high-thread
mutex tests?

Question 2.3.2

Where (what lines of code) are consuming most of the cycles when the spin-lock
version of the list exerciser is run with a large number of threads?

Why does this operation become so expensive with large numbers of threads?


Question 2.3.3

Why does the average lock-wait time rise so dramatically with the number of
contending threads?

Why does the completion time per operation rise (less dramatically) with the
number of contending threads?

How is it possible for the wait time per operation to go up faster (or higher)
than the completion time per operation?

Question 2.3.4

Explain the change in performance of the synchronized methods as a function of
the number of lists.

Should the throughput continue increasing as the number of lists is further
increased? If not, explain why not.

It seems reasonable to suggest the throughput of an N-way partitioned list
should be equivalent to the throughput of a single list with fewer (1/N)
threads. Does this appear to be true in the above curves? If not, explain why
not.

This submission contains:

SortedList.h:

SortedList.c:

lab2_list.c:

Makefile:

lab2b_list.csv:

lab2b_list.gp:

lab2b_1.png:

lab2b_2.png:

lab2b_3.png:

lab2b_4.png:

lab2b_5.png:

profile.out: